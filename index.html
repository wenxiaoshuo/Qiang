<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR 手势射击 - 修正版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial', sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        
        /* 修正：视频不能完全隐藏或透明度为0，否则部分浏览器会停止更新帧 */
        #input-video { 
            position: absolute; top: 0; left: 0; width: 1px; height: 1px; 
            opacity: 0.01; pointer-events: none; z-index: -1; 
        }
        
        /* 渲染层 */
        #output-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; transform: scaleX(-1); }
        
        /* UI 层 */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .score-board { position: absolute; top: 20px; left: 20px; color: #00ffcc; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #00ffcc; }
        .instruction { position: absolute; bottom: 20px; width: 100%; text-align: center; color: rgba(255,255,255,0.7); font-size: 14px; background: rgba(0,0,0,0.5); padding: 5px; }
        
        .float-text { position: absolute; font-weight: 900; font-size: 24px; animation: floatUp 0.8s ease-out forwards; pointer-events: none; }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }

        /* Loading */
        #loading-mask {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 9999; display: flex; flex-direction: column;
            align-items: center; justify-content: center; color: #fff;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 50px; height: 50px; border: 5px solid #333;
            border-top: 5px solid #00ffcc; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        #debug-info {
            position: absolute; top: 60px; left: 20px; color: yellow; font-size: 12px; white-space: pre; z-index: 20;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="loading-mask">
    <div class="spinner"></div>
    <div id="loading-text">正在初始化...<br>(首次加载可能需要10-20秒)</div>
</div>

<div id="container">
    <!-- 修正：添加 muted autoplay 确保自动播放 -->
    <video id="input-video" playsinline muted autoplay></video>
    <canvas id="output-canvas"></canvas>
    <div id="ui-layer">
        <div class="score-board">SCORE: <span id="score">0</span></div>
        <div id="debug-info">等待摄像头...</div>
        <div class="instruction">请确保光线充足 | 食指瞄准 | 拇指扣动</div>
    </div>
</div>

<script>
const MP_VERSION = '0.4.1646424915';
const MP_BASE_URL = `https://unpkg.com/@mediapipe/hands@${MP_VERSION}/`;
const AI_INTERVAL = 2; // 提高检测频率
const SENSITIVITY = 1.6; // 灵敏度倍率，让准心移动范围更大

// 状态管理
const state = {
    score: 0,
    enemies: [],
    lastShotTime: 0,
    isFiring: false,
    handDetected: false,
    rawAimPos: { x: 0, y: 0 },
    aimPos: { x: 0, y: 0 },
    frameInfo: 0
};

// DOM
const videoElement = document.getElementById('input-video');
const canvasElement = document.getElementById('output-canvas');
const scoreEl = document.getElementById('score');
const uiLayer = document.getElementById('ui-layer');
const debugEl = document.getElementById('debug-info');

// Audio
const AudioSys = {
    ctx: new (window.AudioContext || window.webkitAudioContext)(),
    playTone: function(freq, type, duration) {
        if(this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    shoot: function() { this.playTone(800, 'square', 0.1); },
    hit: function() { this.playTone(1200, 'sine', 0.1); },
    miss: function() { this.playTone(150, 'sawtooth', 0.2); }
};

// Three.js Setup
const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(
    window.innerWidth / -2, window.innerWidth / 2,
    window.innerHeight / 2, window.innerHeight / -2,
    1, 1000
);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({ canvas: canvasElement, alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

// Video Background
const videoTexture = new THREE.VideoTexture(videoElement);
videoTexture.minFilter = THREE.LinearFilter;
videoTexture.magFilter = THREE.LinearFilter;
videoTexture.format = THREE.RGBFormat;
const bgGeometry = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
const bgMaterial = new THREE.MeshBasicMaterial({ map: videoTexture });
const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
bgMesh.position.z = -10;
scene.add(bgMesh);

function resizeBackground() {
    if (videoElement.readyState < 2) return;
    const videoAspect = videoElement.videoWidth / videoElement.videoHeight;
    const windowAspect = window.innerWidth / window.innerHeight;
    if (windowAspect > videoAspect) {
        bgMesh.scale.set(1, windowAspect / videoAspect, 1);
    } else {
        bgMesh.scale.set(videoAspect / windowAspect, 1, 1);
    }
}

// Game Objects
const crosshair = new THREE.Mesh(
    new THREE.RingGeometry(15, 20, 32),
    new THREE.MeshBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.8 })
);
scene.add(crosshair);

const laserGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]);
const laserMat = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
const laserLine = new THREE.Line(laserGeo, laserMat);
scene.add(laserLine);

function createEnemy() {
    const geometry = new THREE.CylinderGeometry(25, 25, 5, 32);
    const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    const disc = new THREE.Mesh(geometry, material);
    
    const side = Math.floor(Math.random() * 4);
    const w = window.innerWidth / 2;
    const h = window.innerHeight / 2;
    let x, y;
    
    switch(side) {
        case 0: x = (Math.random() - 0.5) * 2 * w; y = h + 50; break;
        case 1: x = w + 50; y = (Math.random() - 0.5) * 2 * h; break;
        case 2: x = (Math.random() - 0.5) * 2 * w; y = -h - 50; break;
        case 3: x = -w - 50; y = (Math.random() - 0.5) * 2 * h; break;
    }
    
    disc.position.set(x, y, 0);
    disc.rotation.x = Math.PI / 2;
    const speed = 2 + Math.random() * 2;
    const angle = Math.atan2(-y, -x);
    disc.userData = { vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, active: true };
    scene.add(disc);
    state.enemies.push(disc);
}

function showFloatingText(text, x, y, color) {
    const div = document.createElement('div');
    div.className = 'float-text';
    div.innerText = text;
    div.style.left = (window.innerWidth/2 + x) + 'px';
    div.style.top = (window.innerHeight/2 - y) + 'px';
    div.style.color = color;
    uiLayer.appendChild(div);
    setTimeout(() => div.remove(), 800);
}

// MediaPipe Setup
const hands = new Hands({locateFile: (file) => `${MP_BASE_URL}${file}`});
hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});

hands.onResults((results) => {
    // 调试信息
    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
        state.handDetected = false;
        debugEl.innerText = "未检测到手部\n请将手举在摄像头前";
        return;
    }
    
    state.handDetected = true;
    const landmarks = results.multiHandLandmarks[0];
    const indexTip = landmarks[8];
    const indexBase = landmarks[5];
    const thumbTip = landmarks[4];
    
    // 坐标映射修正 (增加 SENSITIVITY)
    const w = window.innerWidth;
    const h = window.innerHeight;
    
    // MediaPipe x 轴: 0(左) -> 1(右)。 ThreeJS x 轴: 负(左) -> 正(右)
    // 需要镜像反转: (0.5 - x)
    const tipX = (0.5 - indexTip.x) * w * SENSITIVITY;
    const tipY = (0.5 - indexTip.y) * h * SENSITIVITY;
    const baseX = (0.5 - indexBase.x) * w * SENSITIVITY;
    const baseY = (0.5 - indexBase.y) * h * SENSITIVITY;

    state.rawAimPos = { x: tipX, y: tipY };

    debugEl.innerText = `检测中...\nX: ${tipX.toFixed(0)} Y: ${tipY.toFixed(0)}`;

    // 磁吸
    let closestDist = 200; // 增大磁吸半径
    let targetPos = null;
    
    state.enemies.forEach(enemy => {
        if (!enemy.userData.active) return;
        const dist = Math.sqrt(Math.pow(enemy.position.x - tipX, 2) + Math.pow(enemy.position.y - tipY, 2));
        if (dist < closestDist) {
            closestDist = dist;
            targetPos = enemy.position;
        }
    });

    if (targetPos) {
        state.aimPos.x += (targetPos.x - state.aimPos.x) * 0.4;
        state.aimPos.y += (targetPos.y - state.aimPos.y) * 0.4;
        crosshair.material.color.setHex(0xff0000);
    } else {
        state.aimPos.x += (state.rawAimPos.x - state.aimPos.x) * 0.3;
        state.aimPos.y += (state.rawAimPos.y - state.aimPos.y) * 0.3;
        crosshair.material.color.setHex(0x00ffcc);
    }

    // 更新3D对象
    crosshair.position.set(state.aimPos.x, state.aimPos.y, 0);
    laserGeo.setFromPoints([new THREE.Vector3(baseX, baseY, 0), new THREE.Vector3(state.aimPos.x, state.aimPos.y, 0)]);
    laserGeo.attributes.position.needsUpdate = true;

    // 射击检测
    const triggerDist = Math.sqrt(Math.pow(thumbTip.x - indexBase.x, 2) + Math.pow(thumbTip.y - indexBase.y, 2));
    if (triggerDist < 0.08) { // 放宽判定
        if (!state.isFiring && Date.now() - state.lastShotTime > 300) {
            fireShot();
        }
        state.isFiring = true;
    } else {
        state.isFiring = false;
    }
});

function fireShot() {
    state.lastShotTime = Date.now();
    AudioSys.shoot();
    
    // 视觉反馈
    crosshair.scale.set(1.5, 1.5, 1.5);
    setTimeout(() => crosshair.scale.set(1, 1, 1), 100);

    let hit = false;
    for (let i = 0; i < state.enemies.length; i++) {
        const enemy = state.enemies[i];
        if (!enemy.userData.active) continue;
        const dist = Math.sqrt(Math.pow(state.aimPos.x - enemy.position.x, 2) + Math.pow(state.aimPos.y - enemy.position.y, 2));
        
        if (dist < 60) { // 命中半径
            hit = true;
            enemy.userData.active = false;
            scene.remove(enemy);
            state.enemies.splice(i, 1);
            i--;
            state.score += 100;
            scoreEl.innerText = state.score;
            AudioSys.hit();
            showFloatingText("HIT!", state.aimPos.x, state.aimPos.y, "#00ff00");
            break; 
        }
    }
    if (!hit) {
        AudioSys.miss();
        showFloatingText("MISS", state.aimPos.x, state.aimPos.y, "#ff0000");
    }
}

async function startGame() {
    const loadingMask = document.getElementById('loading-mask');
    const loadingText = document.getElementById('loading-text');

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            try {
                // 确保视频正在播放
                if (videoElement.paused) await videoElement.play();
                
                state.frameInfo++;
                if (state.frameInfo % AI_INTERVAL === 0) {
                    await hands.send({image: videoElement});
                }
            } catch (e) {
                // 忽略帧丢失错误
            }
        },
        width: 1280,
        height: 720
    });

    try {
        await cameraUtils.start();
        loadingText.innerHTML = "加载完成！<br>请点击屏幕开启声音";
        
        // 点击任意处开始（为了解除 AudioContext 锁定）
        const startHandler = () => {
            loadingMask.style.opacity = 0;
            setTimeout(() => loadingMask.style.display = 'none', 500);
            if(AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();
            document.removeEventListener('click', startHandler);
        };
        document.addEventListener('click', startHandler);
        
        animate();
    } catch (e) {
        loadingText.innerText = "错误：请检查摄像头权限或使用 HTTPS/localhost";
        console.error(e);
    }
}

function animate() {
    requestAnimationFrame(animate);
    
    if (videoElement.readyState === 4) {
        videoTexture.needsUpdate = true;
    }
    
    crosshair.visible = state.handDetected;
    laserLine.visible = state.handDetected;

    // 敌人生成
    if (state.enemies.length < 4 && Math.random() < 0.05) {
        createEnemy();
    }

    state.enemies.forEach((enemy, index) => {
        if (!enemy.userData.active) return;
        enemy.position.x += enemy.userData.vx;
        enemy.position.y += enemy.userData.vy;
        enemy.rotation.x += 0.05;
        
        const dist = Math.sqrt(enemy.position.x**2 + enemy.position.y**2);
        if (dist < 30) {
             enemy.userData.active = false;
             scene.remove(enemy);
             state.enemies.splice(index, 1);
             state.score = Math.max(0, state.score - 50);
             scoreEl.innerText = state.score;
             document.body.style.backgroundColor = '#300';
             setTimeout(() => document.body.style.backgroundColor = '#000', 100);
        }
    });

    resizeBackground();
    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.left = window.innerWidth / -2;
    camera.right = window.innerWidth / 2;
    camera.top = window.innerHeight / 2;
    camera.bottom = window.innerHeight / -2;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    bgMesh.geometry = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
    resizeBackground();
});

startGame();
</script>
</body>
</html>
