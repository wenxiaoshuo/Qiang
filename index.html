<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR 手势射击 - 磁吸版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial', sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        
        /* 视频层（隐藏，仅用于AI分析） */
        #input-video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); opacity: 0; pointer-events: none; }
        
        /* 渲染层 */
        #output-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; transform: scaleX(-1); /* 镜像翻转以匹配摄像头 */ }
        
        /* UI 层 */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .score-board { position: absolute; top: 20px; left: 20px; color: #00ffcc; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #00ffcc; }
        .instruction { position: absolute; bottom: 20px; width: 100%; text-align: center; color: rgba(255,255,255,0.7); font-size: 14px; }
        
        /* 浮动文字特效 */
        .float-text { position: absolute; font-weight: 900; font-size: 24px; animation: floatUp 0.8s ease-out forwards; pointer-events: none; }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }

        /* Loading 遮罩 */
        #loading-mask {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 9999; display: flex; flex-direction: column;
            align-items: center; justify-content: center; color: #fff;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 50px; height: 50px; border: 5px solid #333;
            border-top: 5px solid #00ffcc; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands (特定版本锁定) -->
    <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="loading-mask">
    <div class="spinner"></div>
    <div id="loading-text">正在初始化神经网络...</div>
</div>

<div id="container">
    <video id="input-video" playsinline></video>
    <canvas id="output-canvas"></canvas>
    <div id="ui-layer">
        <div class="score-board">SCORE: <span id="score">0</span></div>
        <div class="instruction">摆出“手枪”手势：食指瞄准，拇指扣动射击</div>
    </div>
</div>

<script>
/**
 * 配置与常量
 */
const MP_VERSION = '0.4.1646424915';
const MP_BASE_URL = `https://unpkg.com/@mediapipe/hands@${MP_VERSION}/`;
const TARGET_FPS = 60; // 渲染帧率
const AI_INTERVAL = 3; // AI检测降频：每3帧检测一次，防止卡顿

// 游戏状态
const state = {
    score: 0,
    enemies: [], // 飞盘对象
    bullets: [],
    lastShotTime: 0,
    isFiring: false,
    handDetected: false,
    rawAimPos: { x: 0, y: 0 }, // 原始手势坐标
    aimPos: { x: 0, y: 0 },    // 经过磁吸修正的坐标
    frameInfo: 0
};

// DOM 元素
const videoElement = document.getElementById('input-video');
const canvasElement = document.getElementById('output-canvas');
const scoreEl = document.getElementById('score');
const uiLayer = document.getElementById('ui-layer');

/**
 * 音效管理器 (使用 AudioContext 合成，无需外部文件)
 */
const AudioSys = {
    ctx: new (window.AudioContext || window.webkitAudioContext)(),
    playTone: function(freq, type, duration) {
        if(this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    shoot: function() { this.playTone(800, 'square', 0.1); this.playTone(600, 'sawtooth', 0.15); },
    hit: function() { this.playTone(1200, 'sine', 0.1); },
    miss: function() { this.playTone(150, 'sawtooth', 0.2); }
};

/**
 * Three.js 场景初始化
 */
const scene = new THREE.Scene();
// 使用正交相机匹配 2D 屏幕操作
const camera = new THREE.OrthographicCamera(
    window.innerWidth / -2, window.innerWidth / 2,
    window.innerHeight / 2, window.innerHeight / -2,
    1, 1000
);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({ canvas: canvasElement, alpha: true, antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

// 视频背景纹理 (AR效果)
const videoTexture = new THREE.VideoTexture(videoElement);
const bgGeometry = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
const bgMaterial = new THREE.MeshBasicMaterial({ map: videoTexture });
const bgMesh = new THREE.Mesh(bgGeometry, bgMaterial);
bgMesh.position.z = -10;
scene.add(bgMesh);

// 调整背景比例
function resizeBackground() {
    const videoAspect = videoElement.videoWidth / videoElement.videoHeight;
    const windowAspect = window.innerWidth / window.innerHeight;
    
    // 简单的 Cover 模式适配
    if (windowAspect > videoAspect) {
        bgMesh.scale.set(1, windowAspect / videoAspect, 1);
    } else {
        bgMesh.scale.set(videoAspect / windowAspect, 1, 1);
    }
}

/**
 * 游戏对象生成
 */
// 准心 (激光点)
const crosshairGeo = new THREE.RingGeometry(15, 20, 32);
const crosshairMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.8 });
const crosshair = new THREE.Mesh(crosshairGeo, crosshairMat);
scene.add(crosshair);

// 激光线
const laserGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]);
const laserMat = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 });
const laserLine = new THREE.Line(laserGeo, laserMat);
scene.add(laserLine);

// 飞盘管理器
function createEnemy() {
    const geometry = new THREE.CylinderGeometry(30, 30, 5, 32);
    const material = new THREE.MeshBasicMaterial({ color: Math.random() * 0xffffff });
    const disc = new THREE.Mesh(geometry, material);
    
    // 随机边缘位置
    const side = Math.floor(Math.random() * 4); // 0:top, 1:right, 2:bottom, 3:left
    const w = window.innerWidth / 2;
    const h = window.innerHeight / 2;
    let x, y;
    
    switch(side) {
        case 0: x = (Math.random() - 0.5) * 2 * w; y = h + 50; break;
        case 1: x = w + 50; y = (Math.random() - 0.5) * 2 * h; break;
        case 2: x = (Math.random() - 0.5) * 2 * w; y = -h - 50; break;
        case 3: x = -w - 50; y = (Math.random() - 0.5) * 2 * h; break;
    }
    
    disc.position.set(x, y, 0);
    disc.rotation.x = Math.PI / 2; // 面向相机
    
    // 速度向量指向中心
    const speed = 2 + Math.random() * 3;
    const angle = Math.atan2(-y, -x);
    disc.userData = { 
        vx: Math.cos(angle) * speed, 
        vy: Math.sin(angle) * speed,
        active: true 
    };
    
    scene.add(disc);
    state.enemies.push(disc);
}

// 浮动文字工厂
function showFloatingText(text, x, y, color) {
    const div = document.createElement('div');
    div.className = 'float-text';
    div.innerText = text;
    div.style.left = (window.innerWidth/2 + x) + 'px';
    div.style.top = (window.innerHeight/2 - y) + 'px'; // Y轴反转
    div.style.color = color;
    uiLayer.appendChild(div);
    setTimeout(() => div.remove(), 800);
}

/**
 * 核心逻辑：MediaPipe 手势识别
 */
const hands = new Hands({locateFile: (file) => {
    // 强制版本锁定，防止 WASM 404
    return `${MP_BASE_URL}${file}`;
}});

hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});

hands.onResults(onResults);

function onResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        state.handDetected = true;
        const landmarks = results.multiHandLandmarks[0];
        
        // 关键点：5(食指根), 8(食指尖), 4(拇指尖), 3(拇指IP), 0(手腕)
        const indexBase = landmarks[5];
        const indexTip = landmarks[8];
        const thumbTip = landmarks[4];
        
        // 1. 计算瞄准方向 (手腕 -> 食指尖 映射到屏幕)
        // MediaPipe 坐标是 0-1，需要转换到 Three.js 坐标系
        const w = window.innerWidth;
        const h = window.innerHeight;
        
        // 映射 Tip 坐标到屏幕中心坐标系
        const tipX = (0.5 - indexTip.x) * w; // 镜像翻转 X
        const tipY = (0.5 - indexTip.y) * h;
        
        // 映射 Base 坐标用于计算激光方向
        const baseX = (0.5 - indexBase.x) * w;
        const baseY = (0.5 - indexBase.y) * h;

        // 设置原始瞄准点 (食指尖延伸)
        // 简单的做法：直接用食指尖位置作为准心，或者做射线延伸
        // 这里为了游戏性，直接跟随食指尖，但加上平滑和磁吸
        state.rawAimPos = { x: tipX, y: tipY };
        
        // 激光起点 (食指根)
        const laserStart = new THREE.Vector3(baseX, baseY, 0);
        
        // 2. 磁吸辅助
        let closestDist = 150; // 磁吸半径
        let targetPos = null;
        
        state.enemies.forEach(enemy => {
            if (!enemy.userData.active) return;
            const dx = enemy.position.x - tipX;
            const dy = enemy.position.y - tipY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < closestDist) {
                closestDist = dist;
                targetPos = enemy.position;
            }
        });

        if (targetPos) {
            // Lerp 过去，产生磁吸感
            state.aimPos.x += (targetPos.x - state.aimPos.x) * 0.3;
            state.aimPos.y += (targetPos.y - state.aimPos.y) * 0.3;
            crosshairMat.color.setHex(0xff0000); // 锁定变红
        } else {
            state.aimPos.x += (state.rawAimPos.x - state.aimPos.x) * 0.2;
            state.aimPos.y += (state.rawAimPos.y - state.aimPos.y) * 0.2;
            crosshairMat.color.setHex(0x00ffcc);
        }

        // 更新准心和激光
        crosshair.position.set(state.aimPos.x, state.aimPos.y, 0);
        laserGeo.setFromPoints([laserStart, new THREE.Vector3(state.aimPos.x, state.aimPos.y, 0)]);
        laserGeo.attributes.position.needsUpdate = true;

        // 3. 射击检测 (大拇指动作)
        // 计算拇指尖到食指根部的距离。距离变短说明扣动了扳机
        // 使用 3D 距离更准确，但这里 2D 足够
        const triggerDist = Math.sqrt(Math.pow(thumbTip.x - indexBase.x, 2) + Math.pow(thumbTip.y - indexBase.y, 2));
        
        // 阈值需要调试，通常 0.05 - 0.1 之间是张开，< 0.04 是闭合
        // 为了鲁棒性，使用状态机
        const TRIGGER_THRESHOLD = 0.06; 
        
        if (triggerDist < TRIGGER_THRESHOLD) {
            if (!state.isFiring && Date.now() - state.lastShotTime > 300) {
                fireShot();
            }
            state.isFiring = true;
        } else {
            state.isFiring = false;
        }

    } else {
        state.handDetected = false;
        crosshair.visible = false;
        laserLine.visible = false;
    }
}

function fireShot() {
    state.lastShotTime = Date.now();
    AudioSys.shoot();
    
    // 视觉反馈：准心扩散
    const originalScale = crosshair.scale.x;
    crosshair.scale.set(2, 2, 2);
    setTimeout(() => crosshair.scale.set(1, 1, 1), 100);

    // 碰撞检测
    let hit = false;
    // 简单的圆形碰撞，因为准心已经吸附了，如果此时准心在敌人半径内，就算命中
    for (let i = 0; i < state.enemies.length; i++) {
        const enemy = state.enemies[i];
        if (!enemy.userData.active) continue;

        const dx = state.aimPos.x - enemy.position.x;
        const dy = state.aimPos.y - enemy.position.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < 40) { // 命中阈值
            hit = true;
            // 击碎逻辑
            enemy.userData.active = false;
            scene.remove(enemy);
            state.enemies.splice(i, 1);
            i--; // 修正索引
            
            // 特效
            state.score += 100;
            scoreEl.innerText = state.score;
            AudioSys.hit();
            showFloatingText("HIT!", state.aimPos.x, state.aimPos.y, "#00ff00");
            break; // 一次只打一个
        }
    }

    if (!hit) {
        AudioSys.miss();
        showFloatingText("MISS", state.aimPos.x, state.aimPos.y, "#ff0000");
    }
}

/**
 * 主循环
 */
async function startGame() {
    const loadingMask = document.getElementById('loading-mask');
    const loadingText = document.getElementById('loading-text');

    // 启动摄像头
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            // 防报错 try-catch 包裹 MediaPipe 发送
            try {
                // 性能优化：限制 AI 检测频率
                state.frameInfo++;
                if (state.frameInfo % AI_INTERVAL === 0) {
                    await hands.send({image: videoElement});
                }
            } catch (e) {
                console.warn("MediaPipe Error suppressed:", e);
            }
        },
        width: 1280,
        height: 720
    });

    try {
        await cameraUtils.start();
        loadingText.innerText = "加载完成，准备战斗！";
        setTimeout(() => {
            loadingMask.style.opacity = 0;
            setTimeout(() => loadingMask.style.display = 'none', 500);
        }, 1000);
        
        animate();
    } catch (e) {
        loadingText.innerText = "摄像头启动失败，请检查权限。";
        console.error(e);
    }
}

function animate() {
    requestAnimationFrame(animate);
    
    // 渲染更新
    if (videoElement.readyState === videoElement.HAVE_ENOUGH_DATA) {
         if (videoTexture) videoTexture.needsUpdate = true;
    }
    
    // 准心可见性控制
    if (state.handDetected) {
        crosshair.visible = true;
        laserLine.visible = true;
    }

    // 敌人逻辑
    // 1. 补位
    while (state.enemies.length < 4) {
        createEnemy();
    }

    // 2. 移动与更新
    state.enemies.forEach((enemy, index) => {
        if (!enemy.userData.active) return;
        
        enemy.position.x += enemy.userData.vx;
        enemy.position.y += enemy.userData.vy;
        
        enemy.rotation.x += 0.05;
        enemy.rotation.z += 0.05;

        // 出界检测 (飞过中心一段距离后移除，或者飞出屏幕)
        // 简单判定：如果飞得太远（穿过中心到了另一边），移除
        const distFromCenter = Math.sqrt(enemy.position.x**2 + enemy.position.y**2);
        
        // 如果飞盘接近中心 (例如 r < 50)，判定为攻击玩家，扣分并重置
        if (distFromCenter < 50) {
             enemy.userData.active = false;
             scene.remove(enemy);
             state.enemies.splice(index, 1);
             state.score = Math.max(0, state.score - 50);
             scoreEl.innerText = state.score;
             showFloatingText("OUCH!", 0, 0, "#ff00ff");
             // 屏幕震动
             document.body.style.transform = `translate(${Math.random()*10-5}px, ${Math.random()*10-5}px)`;
             setTimeout(() => document.body.style.transform = 'none', 100);
        }
    });

    resizeBackground();
    renderer.render(scene, camera);
}

// 窗口调整
window.addEventListener('resize', () => {
    camera.left = window.innerWidth / -2;
    camera.right = window.innerWidth / 2;
    camera.top = window.innerHeight / 2;
    camera.bottom = window.innerHeight / -2;
    camera.updateProjectionMatrix();
    
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    bgMesh.geometry = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
    resizeBackground();
});

// 启动
startGame();

</script>
</body>
</html>