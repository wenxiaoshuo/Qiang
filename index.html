<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR 极速射击 - 性能优化版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial', sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; }
        
        /* 隐藏原始视频，但在DOM中保留用于AI读取 */
        #input-video { display: none; }
        
        /* 主游戏画面 */
        #output-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; z-index: 1; }
        
        /* 右上角手势监控窗 (画中画) */
        #monitor-container {
            position: absolute; top: 10px; right: 10px; 
            width: 160px; height: 120px; 
            border: 2px solid #00ffcc; background: rgba(0,0,0,0.5);
            z-index: 20; overflow: hidden; border-radius: 8px;
            transform: scaleX(-1); /* 镜像翻转，符合镜子直觉 */
        }
        #monitor-canvas { width: 100%; height: 100%; object-fit: cover; }
        
        /* UI 层 */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .score-board { position: absolute; top: 20px; left: 20px; color: #00ffcc; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #00ffcc; }
        .fps-counter { position: absolute; top: 50px; left: 20px; color: #ffff00; font-size: 12px; }
        
        /* 浮动文字 */
        .float-text { position: absolute; font-weight: 900; font-size: 24px; animation: floatUp 0.8s ease-out forwards; pointer-events: none; }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }

        /* Loading */
        #loading-mask {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 9999; display: flex; flex-direction: column;
            align-items: center; justify-content: center; color: #fff;
            transition: opacity 0.5s;
        }
        .spinner {
            width: 40px; height: 40px; border: 4px solid #333;
            border-top: 4px solid #00ffcc; border-radius: 50%;
            animation: spin 0.8s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
    
    <!-- 核心库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe 强制锁定版本 -->
    <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <!-- 绘图工具 (用于右上角监控) -->
    <script src="https://unpkg.com/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="loading-mask">
    <div class="spinner"></div>
    <div id="loading-text">正在启动引擎...<br>Lite模型加载中</div>
</div>

<div id="container">
    <video id="input-video" playsinline muted autoplay></video>
    <canvas id="output-canvas"></canvas>
    
    <!-- 右上角监控 -->
    <div id="monitor-container">
        <canvas id="monitor-canvas"></canvas>
    </div>

    <div id="ui-layer">
        <div class="score-board">SCORE: <span id="score">0</span></div>
        <div class="fps-counter" id="fps-meter">FPS: 60 | AI: Init</div>
    </div>
</div>

<script>
/**
 * 性能配置区
 */
const CONFIG = {
    cameraWidth: 640,  // 降低分辨率以提速 (原1280)
    cameraHeight: 480,
    aiInterval: 4,     // 每4帧检测一次AI (大幅降低CPU占用)
    sensitivity: 1.8,  // 手势灵敏度
    lerpFactor: 0.2    // 平滑插值系数 (0.1很滑, 0.5很灵敏)
};

const MP_VERSION = '0.4.1646424915';
const MP_BASE_URL = `https://unpkg.com/@mediapipe/hands@${MP_VERSION}/`;

// 状态管理
const state = {
    score: 0,
    enemies: [],
    lastShotTime: 0,
    isFiring: false,
    handDetected: false,
    targetAimPos: { x: 0, y: 0 }, // AI 计算出的目标点
    currentAimPos: { x: 0, y: 0 }, // 当前平滑后的准心点
    frameCount: 0,
    fps: 0,
    lastTime: performance.now()
};

// DOM
const videoElement = document.getElementById('input-video');
const canvasElement = document.getElementById('output-canvas');
const monitorCanvas = document.getElementById('monitor-canvas');
const monitorCtx = monitorCanvas.getContext('2d');
const scoreEl = document.getElementById('score');
const fpsEl = document.getElementById('fps-meter');
const uiLayer = document.getElementById('ui-layer');

// Audio System
const AudioSys = {
    ctx: new (window.AudioContext || window.webkitAudioContext)(),
    playTone: function(freq, type, duration) {
        if(this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    shoot: function() { this.playTone(600, 'square', 0.08); },
    hit: function() { this.playTone(1000, 'sine', 0.1); },
    miss: function() { this.playTone(150, 'sawtooth', 0.1); }
};

// Three.js 初始化
const scene = new THREE.Scene();
const camera = new THREE.OrthographicCamera(
    window.innerWidth / -2, window.innerWidth / 2,
    window.innerHeight / 2, window.innerHeight / -2,
    1, 1000
);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({ canvas: canvasElement, alpha: true, antialias: false }); // 关闭抗锯齿提速
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // 限制像素比

// 视频背景 (AR)
const videoTexture = new THREE.VideoTexture(videoElement);
videoTexture.minFilter = THREE.LinearFilter;
const bgMesh = new THREE.Mesh(
    new THREE.PlaneGeometry(window.innerWidth, window.innerHeight),
    new THREE.MeshBasicMaterial({ map: videoTexture, depthTest: false }) // 关闭深度测试提速
);
bgMesh.position.z = -10;
// 镜像翻转背景以匹配操作习惯
bgMesh.scale.x = -1; 
scene.add(bgMesh);

// 准心与激光
const crosshair = new THREE.Mesh(
    new THREE.RingGeometry(15, 20, 16), // 减少面数
    new THREE.MeshBasicMaterial({ color: 0x00ffcc, transparent: true, opacity: 0.8 })
);
scene.add(crosshair);

const laserGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]);
const laserLine = new THREE.Line(laserGeo, new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 2 }));
scene.add(laserLine);

// 敌人系统
function createEnemy() {
    // 使用低多边形几何体
    const geometry = new THREE.IcosahedronGeometry(25, 0); 
    const material = new THREE.MeshBasicMaterial({ color: 0xff3333, wireframe: true });
    const enemy = new THREE.Mesh(geometry, material);
    
    // 随机位置逻辑
    const side = Math.floor(Math.random() * 4);
    const w = window.innerWidth / 2;
    const h = window.innerHeight / 2;
    let x, y;
    switch(side) {
        case 0: x = (Math.random()-0.5)*2*w; y = h+50; break;
        case 1: x = w+50; y = (Math.random()-0.5)*2*h; break;
        case 2: x = (Math.random()-0.5)*2*w; y = -h-50; break;
        case 3: x = -w-50; y = (Math.random()-0.5)*2*h; break;
    }
    enemy.position.set(x, y, 0);
    
    const speed = 2 + Math.random() * 2;
    const angle = Math.atan2(-y, -x);
    enemy.userData = { vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, active: true };
    scene.add(enemy);
    state.enemies.push(enemy);
}

// MediaPipe 核心
const hands = new Hands({locateFile: (file) => `${MP_BASE_URL}${file}`});
// 关键优化：使用 lite 模型 (modelComplexity: 0)
hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 0, 
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});

hands.onResults((results) => {
    // 1. 在右上角绘制监控画面
    monitorCtx.clearRect(0, 0, monitorCanvas.width, monitorCanvas.height);
    monitorCtx.drawImage(results.image, 0, 0, monitorCanvas.width, monitorCanvas.height);
    
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        state.handDetected = true;
        const landmarks = results.multiHandLandmarks[0];
        
        // 绘制骨架到监控窗
        drawConnectors(monitorCtx, landmarks, HAND_CONNECTIONS, {color: '#00ffcc', lineWidth: 2});
        
        // 游戏逻辑
        const indexTip = landmarks[8];
        const indexBase = landmarks[5];
        const thumbTip = landmarks[4];
        
        // 坐标映射
        const w = window.innerWidth;
        const h = window.innerHeight;
        
        // 原始坐标 (用于平滑目标)
        // 注意：因为背景 scale.x = -1 做了镜像，这里的 X 坐标需要对应处理
        const rawX = (0.5 - indexTip.x) * w * CONFIG.sensitivity;
        const rawY = (0.5 - indexTip.y) * h * CONFIG.sensitivity;
        
        state.targetAimPos = { x: rawX, y: rawY };
        
        // 射击触发 (拇指距离)
        const triggerDist = Math.sqrt(Math.pow(thumbTip.x - indexBase.x, 2) + Math.pow(thumbTip.y - indexBase.y, 2));
        if (triggerDist < 0.08) {
             if (!state.isFiring && Date.now() - state.lastShotTime > 250) fireShot();
             state.isFiring = true;
        } else {
             state.isFiring = false;
        }
        
        // 激光起点 (稍微偏移一点)
        laserLine.userData.start = {
             x: (0.5 - indexBase.x) * w * CONFIG.sensitivity,
             y: (0.5 - indexBase.y) * h * CONFIG.sensitivity
        };

    } else {
        state.handDetected = false;
    }
});

function fireShot() {
    state.lastShotTime = Date.now();
    AudioSys.shoot();
    
    // 视觉反馈
    crosshair.scale.set(1.4, 1.4, 1.4);
    setTimeout(() => crosshair.scale.set(1, 1, 1), 100);

    // 碰撞检测
    for (let i = 0; i < state.enemies.length; i++) {
        const enemy = state.enemies[i];
        if (!enemy.userData.active) continue;
        
        // 使用 currentAimPos (平滑后的坐标)
        const dx = state.currentAimPos.x - enemy.position.x;
        const dy = state.currentAimPos.y - enemy.position.y;
        
        if (dx*dx + dy*dy < 3600) { // 60^2
            enemy.userData.active = false;
            scene.remove(enemy);
            state.enemies.splice(i, 1);
            i--;
            state.score += 100;
            scoreEl.innerText = state.score;
            AudioSys.hit();
            showText("HIT!", state.currentAimPos.x, state.currentAimPos.y, "#0f0");
            break;
        }
    }
}

function showText(text, x, y, color) {
    const div = document.createElement('div');
    div.className = 'float-text';
    div.innerText = text;
    div.style.left = (window.innerWidth/2 + x) + 'px';
    div.style.top = (window.innerHeight/2 - y) + 'px';
    div.style.color = color;
    uiLayer.appendChild(div);
    setTimeout(() => div.remove(), 800);
}

// 游戏循环
async function startGame() {
    const loadingMask = document.getElementById('loading-mask');
    const loadingText = document.getElementById('loading-text');

    // 设置监控画布尺寸
    monitorCanvas.width = CONFIG.cameraWidth;
    monitorCanvas.height = CONFIG.cameraHeight;

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            try {
                if(videoElement.paused) await videoElement.play();
                
                // 性能节流：每 N 帧才发送一次给 AI
                state.frameCount++;
                if (state.frameCount % CONFIG.aiInterval === 0) {
                    await hands.send({image: videoElement});
                }
            } catch (e) {}
        },
        width: CONFIG.cameraWidth,
        height: CONFIG.cameraHeight
    });

    try {
        await cameraUtils.start();
        loadingText.innerHTML = "就绪！<br>点击屏幕开始";
        
        const startHandler = () => {
            loadingMask.style.display = 'none';
            if(AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();
            document.removeEventListener('click', startHandler);
        };
        document.addEventListener('click', startHandler);
        
        animate();
    } catch (e) {
        loadingText.innerText = "摄像头启动失败";
        console.error(e);
    }
}

function animate() {
    requestAnimationFrame(animate);

    // 计算 FPS
    const now = performance.now();
    if (now - state.lastTime >= 1000) {
        state.fps = Math.round(1000 / ((now - state.lastTime) / (state.frameCount || 1))); // 粗略估算
        fpsEl.innerText = `FPS: ${Math.round(1000/(now - state.lastTime) * 60)} | Enemies: ${state.enemies.length}`; // 近似显示
        state.lastTime = now;
    }
    
    // 更新背景视频
    if (videoElement.readyState === 4) videoTexture.needsUpdate = true;
    
    // 核心平滑逻辑：插值 (Lerp)
    // 即使 AI 卡顿，渲染层每帧都让准心向目标移动一点点，看起来就很流畅
    const lerp = CONFIG.lerpFactor;
    
    // 磁吸计算
    let targetX = state.targetAimPos.x;
    let targetY = state.targetAimPos.y;
    let magnetized = false;
    
    for(let enemy of state.enemies) {
        const dist = Math.sqrt((enemy.position.x - targetX)**2 + (enemy.position.y - targetY)**2);
        if(dist < 150) { // 磁吸范围
            targetX += (enemy.position.x - targetX) * 0.4; // 强磁吸
            targetY += (enemy.position.y - targetY) * 0.4;
            magnetized = true;
            break;
        }
    }
    
    // 应用平滑
    state.currentAimPos.x += (targetX - state.currentAimPos.x) * lerp;
    state.currentAimPos.y += (targetY - state.currentAimPos.y) * lerp;
    
    // 更新 UI 位置
    if (state.handDetected) {
        crosshair.visible = true;
        laserLine.visible = true;
        crosshair.position.set(state.currentAimPos.x, state.currentAimPos.y, 0);
        crosshair.material.color.setHex(magnetized ? 0xff0000 : 0x00ffcc);
        
        if (laserLine.userData.start) {
            laserGeo.setFromPoints([
                new THREE.Vector3(laserLine.userData.start.x, laserLine.userData.start.y, 0),
                new THREE.Vector3(state.currentAimPos.x, state.currentAimPos.y, 0)
            ]);
            laserGeo.attributes.position.needsUpdate = true;
        }
    } else {
        crosshair.visible = false;
        laserLine.visible = false;
    }

    // 敌人更新
    if (state.enemies.length < 4 && Math.random() < 0.03) createEnemy();
    
    state.enemies.forEach((enemy, index) => {
        if (!enemy.userData.active) return;
        enemy.position.x += enemy.userData.vx;
        enemy.position.y += enemy.userData.vy;
        enemy.rotation.z += 0.02;
        
        if (Math.sqrt(enemy.position.x**2 + enemy.position.y**2) < 40) {
            enemy.userData.active = false;
            scene.remove(enemy);
            state.enemies.splice(index, 1);
            state.score = Math.max(0, state.score - 50);
            scoreEl.innerText = state.score;
            document.body.style.boxShadow = "inset 0 0 50px red";
            setTimeout(() => document.body.style.boxShadow = "none", 100);
        }
    });

    resizeBackground();
    renderer.render(scene, camera);
}

function resizeBackground() {
    // 简单的背景自适应
    const videoAspect = CONFIG.cameraWidth / CONFIG.cameraHeight;
    const windowAspect = window.innerWidth / window.innerHeight;
    if (windowAspect > videoAspect) {
        bgMesh.scale.set(-1, windowAspect / videoAspect, 1); // 保持镜像X
    } else {
        bgMesh.scale.set(-videoAspect / windowAspect, 1, 1);
    }
}

// Resize handler
window.addEventListener('resize', () => {
    camera.left = window.innerWidth / -2;
    camera.right = window.innerWidth / 2;
    camera.top = window.innerHeight / 2;
    camera.bottom = window.innerHeight / -2;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    bgMesh.geometry = new THREE.PlaneGeometry(window.innerWidth, window.innerHeight);
});

// 启动
startGame();
</script>
</body>
</html>
